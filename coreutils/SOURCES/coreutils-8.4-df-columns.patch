diff -up coreutils-8.4/lib/mbsalign.c.orig coreutils-8.4/lib/mbsalign.c
--- coreutils-8.4/lib/mbsalign.c.orig	2013-07-26 17:08:35.655760487 +0200
+++ coreutils-8.4/lib/mbsalign.c	2013-07-26 17:02:36.594726465 +0200
@@ -31,6 +31,8 @@
 # define MIN(a, b) ((a) < (b) ? (a) : (b))
 #endif
 
+#define SIZE_MAX ((size_t) - 1)
+
 /* Replace non printable chars.
    Return 1 if replacement made, 0 otherwise.  */
 
@@ -229,3 +231,40 @@ mbsalign_cleanup:
 
   return ret;
 }
+
+/* A wrapper around mbsalign() to dynamically allocate the
+   minimum amount of memory to store the result.
+   Return NULL on failure.  */
+
+char *
+ambsalign (const char *src, size_t *width, mbs_align_t align, int flags)
+{
+  size_t orig_width = *width;
+  size_t size = *width;         /* Start with enough for unibyte mode.  */
+  size_t req = size;
+  char *buf = NULL;
+
+  while (req >= size)
+    {
+      char *nbuf;
+      size = req + 1;           /* Space for NUL.  */
+      nbuf = realloc (buf, size);
+      if (nbuf == NULL)
+        {
+          free (buf);
+          buf = NULL;
+          break;
+        }
+      buf = nbuf;
+      *width = orig_width;
+      req = mbsalign (src, buf, size, width, align, flags);
+      if (req == SIZE_MAX)
+        {
+          free (buf);
+          buf = NULL;
+          break;
+        }
+    }
+
+  return buf;
+}
diff -up coreutils-8.4/lib/mbsalign.h.orig coreutils-8.4/lib/mbsalign.h
--- coreutils-8.4/lib/mbsalign.h.orig	2013-07-26 17:08:30.791759138 +0200
+++ coreutils-8.4/lib/mbsalign.h	2013-07-26 17:02:36.594726465 +0200
@@ -18,6 +18,42 @@
 
 typedef enum { MBS_ALIGN_LEFT, MBS_ALIGN_RIGHT, MBS_ALIGN_CENTER } mbs_align_t;
 
+enum {
+  /* Use unibyte mode for invalid multibyte strings
+     or when heap memory is exhausted.  */
+  MBA_UNIBYTE_FALLBACK = 0x0001,
+
+  /* As an optimization, don't do multibyte processing
+     when we know no multibyte characters are present.  */
+  MBA_UNIBYTE_ONLY = 0x0002,
+
+  /* Don't add leading padding.  */
+  MBA_NO_LEFT_PAD = 0x0004,
+
+  /* Don't add trailing padding.  */
+  MBA_NO_RIGHT_PAD = 0x0008
+
+#if 0 /* Other possible options.  */
+  /* Skip invalid multibyte chars rather than failing.  */
+  MBA_IGNORE_INVALID
+
+  /* Align multibyte strings using "figure space" (\u2007).  */
+  MBA_USE_FIGURE_SPACE
+
+  /* Don't truncate.  */
+  MBA_NO_TRUNCATE
+
+  /* Ensure no leading whitespace.  */
+  MBA_LSTRIP
+
+  /* Ensure no trailing whitespace.  */
+  MBA_RSTRIP
+#endif
+};
+
+char *
+ambsalign (const char *src, size_t *width, mbs_align_t align, int flags);
+
 size_t
 mbsalign (const char *src, char *dest, size_t dest_size,
           size_t *width, mbs_align_t align, int flags);
diff -up coreutils-8.4/src/df.c.orig coreutils-8.4/src/df.c
--- coreutils-8.4/src/df.c.orig	2013-07-26 17:08:08.798753280 +0200
+++ coreutils-8.4/src/df.c	2013-07-26 17:05:43.034725691 +0200
@@ -22,12 +22,15 @@
 #include <stdio.h>
 #include <sys/types.h>
 #include <getopt.h>
+#include <assert.h>
 
 #include "system.h"
 #include "canonicalize.h"
 #include "error.h"
 #include "fsusage.h"
 #include "human.h"
+#include "mbsalign.h"
+#include "mbswidth.h"
 #include "mountlist.h"
 #include "quote.h"
 #include "save-cwd.h"
@@ -117,8 +120,55 @@ static bool direct_statfs;
 /* Grand total data. */
 static struct fs_usage grand_fsu;
 
+/* Display modes.  */
+enum { DEFAULT_MODE, INODES_MODE, HUMAN_MODE, POSIX_MODE, NMODES };
+static int header_mode = DEFAULT_MODE;
+
+/* Displayable fields.  */
+enum
+{
+  DEV_FIELD,   /* file system */
+  TYPE_FIELD,  /* FS type */
+  TOTAL_FIELD, /* blocks or inodes */
+  USED_FIELD,  /* ditto */
+  FREE_FIELD,  /* ditto */
+  PCENT_FIELD, /* percent used */
+  MNT_FIELD,   /* mount point */
+  NFIELDS
+};
+
+/* Header strings for the above fields in each mode.
+   NULL means to use the header for the default mode.  */
+static const char *headers[NFIELDS][NMODES] = {
+/*  DEFAULT_MODE	INODES_MODE	HUMAN_MODE	POSIX_MODE  */
+  { N_("Filesystem"),   NULL,           NULL,           NULL },
+  { N_("Type"),         NULL,           NULL,           NULL },
+  { N_("blocks"),       N_("Inodes"),   N_("Size"),     NULL },
+  { N_("Used"),         N_("IUsed"),    NULL,           NULL },
+  { N_("Available"),    N_("IFree"),    N_("Avail"),    NULL },
+  { N_("Use%"),         N_("IUse%"),    NULL,           N_("Capacity") },
+  { N_("Mounted on"),   NULL,           NULL,           NULL }
+};
+
+/* Alignments for the 3 textual and 4 numeric fields.  */
+static mbs_align_t alignments[NFIELDS] = {
+  MBS_ALIGN_LEFT, MBS_ALIGN_LEFT,
+  MBS_ALIGN_RIGHT, MBS_ALIGN_RIGHT, MBS_ALIGN_RIGHT, MBS_ALIGN_RIGHT,
+  MBS_ALIGN_LEFT
+};
+
+/* Auto adjusted (up) widths used to align columns.  */
+static size_t widths[NFIELDS] = { 14, 4, 5, 5, 5, 4, 0 };
+
+/* Storage for pointers for each string (cell of table).  */
+static char ***table;
+
+/* The current number of processed rows (including header).  */
+static size_t nrows;
+
 /* For long options that have no equivalent short option, use a
    non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
+
 enum
 {
   NO_SYNC_OPTION = CHAR_MAX + 1,
@@ -148,73 +198,146 @@ static struct option const long_options[
   {NULL, 0, NULL, 0}
 };
 
-static void
-print_header (void)
+/* Replace problematic chars with '?'.
+   Since only control characters are currently considered,
+   this should work in all encodings.  */
+
+static char*
+hide_problematic_chars (char *cell)
 {
-  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
+  char *p = cell;
+  while (*p)
+    {
+      if (iscntrl (to_uchar (*p)))
+        *p = '?';
+      p++;
+    }
+  return cell;
+}
 
-  if (print_type)
-    /* TRANSLATORS:
-       For best results (df header/column alignment), ensure that
-       your translation has the same length as the original.  */
-    fputs (_("Filesystem    Type"), stdout);
-  else
-    fputs (_("Filesystem        "), stdout);
 
-  if (inode_format)
-    /* TRANSLATORS:
-       For best results (df header/column alignment), ensure that
-       your translation has the same length as the original.
-       Also, each column name translation should end at the same
-       column as the corresponding original.  */
-    fputs (_("    Inodes   IUsed   IFree IUse%"), stdout);
-  else if (human_output_opts & human_autoscale)
+static void
+alloc_table_row (void)
+{
+  nrows++;
+  table = xnrealloc (table, nrows, sizeof (char *));
+  table[nrows-1] = xnmalloc (NFIELDS, sizeof (char *));
+}
+
+/* Output each cell in the table, accounting for the
+   alignment and max width of each column.  */
+static void
+print_table (void)
+{
+  size_t field, row;
+  for (row = 0; row < nrows; row ++)
     {
-      if (human_output_opts & human_base_1024)
-        fputs (_("    Size  Used Avail Use%"), stdout);
-      else
-        fputs (_("     Size   Used  Avail Use%"), stdout);
+      for (field = 0; field < NFIELDS; field++)
+        {
+          size_t width = widths[field];
+          char *cell = table[row][field];
+          if (!cell)
+            continue;
+
+          /* Note the DEV_FIELD used to be displayed on it's own line
+             if (!posix_format && mbswidth (cell) > 20), but that
+             functionality is probably more problematic than helpful.  */
+          if (field != 0)
+            putchar (' ');
+          if (field == MNT_FIELD) /* The last one.  */
+            fputs (cell, stdout);
+          else
+            {
+              cell = ambsalign (table[row][field], &width,
+                                alignments[field], MBA_UNIBYTE_FALLBACK);
+              fputs (cell, stdout);
+              free (cell);
+            }
+          IF_LINT (free (table[row][field]));
+        }
+      putchar ('\n');
+      IF_LINT (free (table[row]));
     }
-  else if (posix_format)
-    printf (_(" %s-blocks      Used Available Capacity"),
-            umaxtostr (output_block_size, buf));
-  else
-    {
-      int opts = (human_suppress_point_zero
-                  | human_autoscale | human_SI
-                  | (human_output_opts
-                     & (human_group_digits | human_base_1024 | human_B)));
-
-      /* Prefer the base that makes the human-readable value more exact,
-         if there is a difference.  */
-
-      uintmax_t q1000 = output_block_size;
-      uintmax_t q1024 = output_block_size;
-      bool divisible_by_1000;
-      bool divisible_by_1024;
 
-      do
+    IF_LINT (free (table));
+}
+
+/* Obtain the appropriate header entries.  */
+
+static void
+get_header (void)
+{
+  size_t field;
+
+  alloc_table_row ();
+
+  for (field = 0; field < NFIELDS; field++)
+     {
+      if (field == TYPE_FIELD && !print_type)
         {
-          divisible_by_1000 = q1000 % 1000 == 0;  q1000 /= 1000;
-          divisible_by_1024 = q1024 % 1024 == 0;  q1024 /= 1024;
+          table[nrows-1][field] = NULL;
+          continue;
         }
-      while (divisible_by_1000 & divisible_by_1024);
 
-      if (divisible_by_1000 < divisible_by_1024)
-        opts |= human_base_1024;
-      if (divisible_by_1024 < divisible_by_1000)
-        opts &= ~human_base_1024;
-      if (! (opts & human_base_1024))
-        opts |= human_B;
+      char *cell = NULL;
+      char const *header = _(headers[field][header_mode]);
+      if (!header)
+        header = _(headers[field][DEFAULT_MODE]);
 
-      printf (_(" %4s-blocks      Used Available Use%%"),
-              human_readable (output_block_size, buf, opts, 1, 1));
-    }
+      if (header_mode == DEFAULT_MODE && field == TOTAL_FIELD)
+        {
+          char buf[LONGEST_HUMAN_READABLE + 1];
+          int opts = (human_suppress_point_zero
+                      | human_autoscale | human_SI
+                      | (human_output_opts
+                         & (human_group_digits | human_base_1024 | human_B)));
+
+          /* Prefer the base that makes the human-readable value more exact,
+             if there is a difference.  */
+
+          uintmax_t q1000 = output_block_size;
+          uintmax_t q1024 = output_block_size;
+          bool divisible_by_1000;
+          bool divisible_by_1024;
 
-  if (direct_statfs)
-    fputs (_(" File\n"), stdout);
-  else
-    fputs (_(" Mounted on\n"), stdout);
+          do
+            {
+              divisible_by_1000 = q1000 % 1000 == 0;  q1000 /= 1000;
+              divisible_by_1024 = q1024 % 1024 == 0;  q1024 /= 1024;
+            }
+          while (divisible_by_1000 & divisible_by_1024);
+
+          if (divisible_by_1000 < divisible_by_1024)
+            opts |= human_base_1024;
+          if (divisible_by_1024 < divisible_by_1000)
+            opts &= ~human_base_1024;
+          if (! (opts & human_base_1024))
+            opts |= human_B;
+
+          char *num = human_readable (output_block_size, buf, opts, 1, 1);
+
+          if (asprintf (&cell, "%s-%s", num, header) == -1)
+            cell = NULL;
+        }
+      else if (header_mode == POSIX_MODE && field == TOTAL_FIELD)
+         {
+          char buf[INT_BUFSIZE_BOUND (uintmax_t)];
+          char *num = umaxtostr (output_block_size, buf);
+
+          if (asprintf (&cell, "%s-%s", num, header) == -1)
+            cell = NULL;
+         }
+      else
+        cell = strdup (header);
+      if (!cell)
+        xalloc_die ();
+
+      hide_problematic_chars (cell);
+
+      table[nrows-1][field] = cell;
+
+      widths[field] = MAX (widths[field], mbswidth (cell, 0));
+    }
 }
 
 /* Is FSTYPE a type of file system that should be listed?  */
@@ -326,7 +449,7 @@ has_uuid_suffix (char const *s)
  && strspn (s + len - 36, "-0123456789abcdefABCDEF") == 36);
 }
 
-/* Display a space listing for the disk device with absolute file name DISK.
+/* Obtain a space listing for the disk device with absolute file name DISK.
    If MOUNT_POINT is non-NULL, it is the name of the root of the
    file system on DISK.
    If STAT_FILE is non-null, it is the name of a file within the file
@@ -342,17 +465,14 @@ has_uuid_suffix (char const *s)
    when df is invoked with no non-option argument. See below for details.  */
 
 static void
-show_dev (char const *disk, char const *mount_point,
-          char const *stat_file, char const *fstype,
-          bool me_dummy, bool me_remote,
-          const struct fs_usage *force_fsu,
-          bool process_all)
+get_dev (char const *disk, char const *mount_point,
+         char const *stat_file, char const *fstype,
+         bool me_dummy, bool me_remote,
+         const struct fs_usage *force_fsu,
+         bool process_all)
 {
   struct fs_usage fsu;
-  char buf[3][LONGEST_HUMAN_READABLE + 2];
-  int width;
-  int col1_adjustment = 0;
-  int use_width;
+  char buf[LONGEST_HUMAN_READABLE + 2];
   uintmax_t input_units;
   uintmax_t output_units;
   uintmax_t total;
@@ -362,6 +482,8 @@ show_dev (char const *disk, char const *
   uintmax_t used;
   bool negate_used;
   double pct = -1;
+  char* cell;
+  size_t field;
 
   if (me_remote && show_local_fs)
     return;
@@ -394,9 +516,11 @@ show_dev (char const *disk, char const *
   if (! file_systems_processed)
     {
       file_systems_processed = true;
-      print_header ();
+      get_header ();
     }
 
+  alloc_table_row ();
+
   if (! disk)
     disk = "-";			/* unknown */
 
@@ -421,31 +545,9 @@ show_dev (char const *disk, char const *
   if (! fstype)
     fstype = "-";		/* unknown */
 
-  /* df.c reserved 5 positions for fstype,
-     but that does not suffice for type iso9660 */
-  if (print_type)
-    {
-      size_t disk_name_len = strlen (dev_name);
-      size_t fstype_len = strlen (fstype);
-      if (disk_name_len + fstype_len < 18)
-        printf ("%s%*s  ", dev_name, 18 - (int) disk_name_len, fstype);
-      else if (!posix_format)
-        printf ("%s\n%18s  ", dev_name, fstype);
-      else
-        printf ("%s %s", dev_name, fstype);
-    }
-  else
-    {
-      if (strlen (dev_name) > 20 && !posix_format)
-        printf ("%s\n%20s", dev_name, "");
-      else
-        printf ("%-20s", dev_name);
-    }
 
   if (inode_format)
     {
-      width = 7;
-      use_width = 5;
       input_units = output_units = 1;
       total = fsu.fsu_files;
       available = fsu.fsu_ffree;
@@ -459,22 +561,6 @@ show_dev (char const *disk, char const *
     }
   else
     {
-      if (human_output_opts & human_autoscale)
-        width = 5 + ! (human_output_opts & human_base_1024);
-      else
-        {
-          width = 9;
-          if (posix_format)
-            {
-              uintmax_t b;
-              col1_adjustment = -3;
-              for (b = output_block_size; 9 < b; b /= 10)
-                col1_adjustment++;
-            }
-        }
-      use_width = ((posix_format
-                    && ! (human_output_opts & human_autoscale))
-                   ? 8 : 4);
       input_units = fsu.fsu_blocksize;
       output_units = output_block_size;
       total = fsu.fsu_blocks;
@@ -501,67 +587,104 @@ show_dev (char const *disk, char const *
       negate_used = (total < available_to_root);
     }
 
-  printf (" %*s %*s %*s ",
-          width + col1_adjustment,
-          df_readable (false, total,
-                       buf[0], input_units, output_units),
-          width, df_readable (negate_used, used,
-                              buf[1], input_units, output_units),
-          width, df_readable (negate_available, available,
-                              buf[2], input_units, output_units));
-
-  if (! known_value (used) || ! known_value (available))
-    ;
-  else if (!negate_used
-           && used <= TYPE_MAXIMUM (uintmax_t) / 100
-           && used + available != 0
-           && (used + available < used) == negate_available)
-    {
-      uintmax_t u100 = used * 100;
-      uintmax_t nonroot_total = used + available;
-      pct = u100 / nonroot_total + (u100 % nonroot_total != 0);
-    }
-  else
+  for (field = 0; field < NFIELDS; field++)
     {
-      /* The calculation cannot be done easily with integer
-         arithmetic.  Fall back on floating point.  This can suffer
-         from minor rounding errors, but doing it exactly requires
-         multiple precision arithmetic, and it's not worth the
-         aggravation.  */
-      double u = negate_used ? - (double) - used : used;
-      double a = negate_available ? - (double) - available : available;
-      double nonroot_total = u + a;
-      if (nonroot_total)
+      switch (field)
         {
-          long int lipct = pct = u * 100 / nonroot_total;
-          double ipct = lipct;
+        case DEV_FIELD:
+          cell = xstrdup (disk);
+          break;
+        case TYPE_FIELD:
+          cell = print_type ? xstrdup (fstype) : NULL;
+          break;
+        case TOTAL_FIELD:
+          cell = xstrdup (df_readable (false, total, buf,
+                                       input_units, output_units));
+          break;
+        case USED_FIELD:
+          cell = xstrdup (df_readable (negate_used, used, buf,
+                                       input_units, output_units));
+          break;
+        case FREE_FIELD:
+          cell = xstrdup (df_readable (negate_available, available, buf,
+                                       input_units, output_units));
+          break;
+        case PCENT_FIELD:
+          if (! known_value (used) || ! known_value (available))
+            ;
+          else if (!negate_used
+                   && used <= TYPE_MAXIMUM (uintmax_t) / 100
+                   && used + available != 0
+                   && (used + available < used) == negate_available)
+            {
+              uintmax_t u100 = used * 100;
+              uintmax_t nonroot_total = used + available;
+              pct = u100 / nonroot_total + (u100 % nonroot_total != 0);
+            }
+          else
+            {
+              /* The calculation cannot be done easily with integer
+                 arithmetic.  Fall back on floating point.  This can suffer
+                 from minor rounding errors, but doing it exactly requires
+                 multiple precision arithmetic, and it's not worth the
+                 aggravation.  */
+              double u = negate_used ? - (double) - used : used;
+              double a = negate_available ? - (double) - available : available;
+              double nonroot_total = u + a;
+              if (nonroot_total)
+                {
+                  long int lipct = pct = u * 100 / nonroot_total;
+                  double ipct = lipct;
+
+                  /* Like `pct = ceil (dpct);', but avoid ceil so that
+                     the math library needn't be linked.  */
+                  if (ipct - 1 < pct && pct <= ipct + 1)
+                    pct = ipct + (ipct < pct);
+                }
+            }
 
-          /* Like `pct = ceil (dpct);', but avoid ceil so that
-             the math library needn't be linked.  */
-          if (ipct - 1 < pct && pct <= ipct + 1)
-            pct = ipct + (ipct < pct);
-        }
-    }
+          if (0 <= pct)
+            {
+              if (asprintf (&cell, "%.0f%%", pct) == -1)
+                cell = NULL;
+            }
+          else
+            cell = strdup ("-");
 
-  if (0 <= pct)
-    printf ("%*.0f%%", use_width - 1, pct);
-  else
-    printf ("%*s", use_width, "- ");
+          if (!cell)
+            xalloc_die ();
 
-  if (mount_point)
-    {
+          break;
+
+        case MNT_FIELD:
+          if (mount_point)
+            {
 #ifdef HIDE_AUTOMOUNT_PREFIX
-      /* Don't print the first directory name in MOUNT_POINT if it's an
-         artifact of an automounter.  This is a bit too aggressive to be
-         the default.  */
-      if (strncmp ("/auto/", mount_point, 6) == 0)
-        mount_point += 5;
-      else if (strncmp ("/tmp_mnt/", mount_point, 9) == 0)
-        mount_point += 8;
+              /* Don't print the first directory name in MOUNT_POINT if it's an
+                 artifact of an automounter.  This is a bit too aggressive to be
+                 the default.  */
+              if (strncmp ("/auto/", mount_point, 6) == 0)
+                mount_point += 5;
+              else if (strncmp ("/tmp_mnt/", mount_point, 9) == 0)
+                mount_point += 8;
 #endif
-      printf (" %s", mount_point);
+              cell = xstrdup (mount_point);
+            }
+          else
+            cell = NULL;
+          break;
+
+        default:
+          assert (!"unhandled field");
+        }
+
+      if (cell)
+        {
+          hide_problematic_chars (cell);
+          widths[field] = MAX (widths[field], mbswidth (cell, 0));
+        }
+      table[nrows-1][field] = cell;
     }
-  putchar ('\n');
 }
 
 /* Return the root mountpoint of the file system on which FILE exists, in
@@ -655,7 +778,7 @@ done:
 /* If DISK corresponds to a mount point, show its usage
    and return true.  Otherwise, return false.  */
 static bool
-show_disk (char const *disk)
+get_disk (char const *disk)
 {
   struct mount_entry const *me;
   struct mount_entry const *best_match = NULL;
@@ -666,9 +789,9 @@ show_disk (char const *disk)
 
   if (best_match)
     {
-      show_dev (best_match->me_devname, best_match->me_mountdir, NULL,
-                best_match->me_type, best_match->me_dummy,
-                best_match->me_remote, NULL, false);
+      get_dev (best_match->me_devname, best_match->me_mountdir, NULL,
+               best_match->me_type, best_match->me_dummy,
+               best_match->me_remote, NULL, false);
       return true;
     }
 
@@ -679,7 +802,7 @@ show_disk (char const *disk)
    and show its disk usage.
    STATP must be the result of `stat (POINT, STATP)'.  */
 static void
-show_point (const char *point, const struct stat *statp)
+get_point (const char *point, const struct stat *statp)
 {
   struct stat disk_stats;
   struct mount_entry *me;
@@ -771,9 +894,9 @@ show_point (const char *point, const str
       }
 
   if (best_match)
-    show_dev (best_match->me_devname, best_match->me_mountdir, point,
-              best_match->me_type, best_match->me_dummy, best_match->me_remote,
-              NULL, false);
+    get_dev (best_match->me_devname, best_match->me_mountdir, point,
+             best_match->me_type, best_match->me_dummy, best_match->me_remote,
+             NULL, false);
   else
     {
       /* We couldn't find the mount entry corresponding to POINT.  Go ahead and
@@ -784,7 +907,7 @@ show_point (const char *point, const str
       char *mp = find_mount_point (point, statp);
       if (mp)
         {
-          show_dev (NULL, mp, NULL, NULL, false, false, NULL, false);
+          get_dev (NULL, mp, NULL, NULL, false, false, NULL, false);
           free (mp);
         }
     }
@@ -794,36 +917,36 @@ show_point (const char *point, const str
    for it.  STATP is the results of `stat' on NAME.  */
 
 static void
-show_entry (char const *name, struct stat const *statp)
+get_entry (char const *name, struct stat const *statp)
 {
   if (direct_statfs)
     {
       char *resolved = canonicalize_file_name (name);
       if (resolved)
 	{
-	  show_dev (NULL, resolved, NULL, NULL, false, false, NULL, false);
+	  get_dev (NULL, resolved, NULL, NULL, false, false, NULL, false);
 	  free (resolved);
 	  return;
 	}
     }
 
   if ((S_ISBLK (statp->st_mode) || S_ISCHR (statp->st_mode))
-      && show_disk (name))
+      && get_disk (name))
     return;
 
-  show_point (name, statp);
+  get_point (name, statp);
 }
 
 /* Show all mounted file systems, except perhaps those that are of
    an unselected type or are empty. */
 
 static void
-show_all_entries (void)
+get_all_entries (void)
 {
   struct mount_entry *me;
 
   for (me = mount_list; me; me = me->me_next)
-    show_dev (me->me_devname, me->me_mountdir, NULL, me->me_type,
+    get_dev (me->me_devname, me->me_mountdir, NULL, me->me_type,
               me->me_dummy, me->me_remote, NULL, true);
 }
 
@@ -1030,6 +1153,13 @@ main (int argc, char **argv)
                        &human_output_opts, &output_block_size);
     }
 
+  if (inode_format)
+    header_mode = INODES_MODE;
+  else if (human_output_opts & human_autoscale)
+    header_mode = HUMAN_MODE;
+  else if (posix_format)
+    header_mode = POSIX_MODE;
+
   /* Fail if the same file system type was both selected and excluded.  */
   {
     bool match = false;
@@ -1107,18 +1237,20 @@ main (int argc, char **argv)
 
       for (i = optind; i < argc; ++i)
         if (argv[i])
-          show_entry (argv[i], &stats[i - optind]);
+          get_entry (argv[i], &stats[i - optind]);
     }
   else
-    show_all_entries ();
+    get_all_entries ();
 
   if (print_grand_total)
     {
       if (inode_format)
         grand_fsu.fsu_blocks = 1;
-      show_dev ("total", NULL, NULL, NULL, false, false, &grand_fsu, false);
+      get_dev ("total", NULL, NULL, NULL, false, false, &grand_fsu, false);
     }
 
+  print_table();
+
   if (! file_systems_processed)
     error (EXIT_FAILURE, 0, _("no file systems processed"));
 
