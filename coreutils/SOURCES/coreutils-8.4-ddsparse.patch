diff -urNp coreutils-8.4-orig/doc/coreutils.texi coreutils-8.4/doc/coreutils.texi
--- coreutils-8.4-orig/doc/coreutils.texi	2013-07-24 17:50:50.192869012 +0200
+++ coreutils-8.4/doc/coreutils.texi	2013-07-24 17:51:55.294129474 +0200
@@ -7853,6 +7853,17 @@ Change lowercase letters to uppercase.
 
 The @samp{lcase} and @samp{ucase} conversions are mutually exclusive.
 
+@item sparse
+@opindex sparse
+Try to seek rather than write @sc{nul} output blocks.
+On a file system that supports sparse files, this will create
+sparse output when extending the output file.
+Be careful when using this option in conjunction with
+@samp{conv=notrunc} or @samp{oflag=append}.
+With @samp{conv=notrunc}, existing data in the output
+corresponding to @sc{nul} blocks from the input, will be untouched.
+With @samp{oflag=append} the seeks performed will be ineffective.
+
 @item swab
 @opindex swab @r{(byte-swapping)}
 @cindex byte-swapping
diff -urNp coreutils-8.4-orig/src/dd.c coreutils-8.4/src/dd.c
--- coreutils-8.4-orig/src/dd.c	2013-07-24 17:50:50.193868981 +0200
+++ coreutils-8.4/src/dd.c	2013-07-24 18:00:09.307078869 +0200
@@ -20,6 +20,7 @@
 
 #define SWAB_ALIGN_OFFSET 2
 
+#include <assert.h>
 #include <sys/types.h>
 #include <signal.h>
 #include <getopt.h>
@@ -126,7 +127,8 @@ enum
     C_NOCREAT = 010000,
     C_EXCL = 020000,
     C_FDATASYNC = 040000,
-    C_FSYNC = 0100000
+    C_FSYNC = 0100000,
+    C_SPARSE = 0200000
   };
 
 /* Status bit masks.  */
@@ -162,6 +164,9 @@ static uintmax_t skip_records = 0;
 /* Skip this many records of `output_blocksize' bytes before output. */
 static uintmax_t seek_records = 0;
 
+/* Whether the final output was done with a seek (rather than a write). */
+static bool final_op_was_seek;
+
 /* Copy only this many records.  The default is effectively infinity.  */
 static uintmax_t max_records = (uintmax_t) -1;
 
@@ -257,6 +262,7 @@ static struct symbol_value const convers
   {"unblock", C_UNBLOCK | C_TWOBUFS},	/* Fixed to variable length records. */
   {"lcase", C_LCASE | C_TWOBUFS},	/* Translate upper to lower case. */
   {"ucase", C_UCASE | C_TWOBUFS},	/* Translate lower to upper case. */
+  {"sparse", C_SPARSE},                  /* Try to sparsely write output. */
   {"swab", C_SWAB | C_TWOBUFS},	/* Swap bytes of input. */
   {"noerror", C_NOERROR},	/* Ignore i/o errors. */
   {"nocreat", C_NOCREAT},	/* Do not create output file.  */
@@ -516,6 +522,7 @@ Each CONV symbol may be:\n\
   excl      fail if the output file already exists\n\
   notrunc   do not truncate the output file\n\
   ucase     change lower case to upper case\n\
+  sparse    try to seek rather than write the output for NUL input blocks\n\
   swab      swap every pair of input bytes\n\
 "), stdout);
       fputs (_("\
@@ -841,6 +848,27 @@ iread_fullblock (int fd, char *buf, size
   return nread;
 }
 
+/* Return whether the buffer consists entirely of NULs.
+ Note the word after the buffer must be non NUL. */
+
+static bool
+is_nul (const char *buf, size_t bufsize)
+{
+ typedef uintptr_t word;
+
+ /* Find first nonzero *word*, or the word with the sentinel. */
+ word *wp = (word *) buf;
+ while (*wp++ == 0)
+ continue;
+
+ /* Find the first nonzero *byte*, or the sentinel. */
+ char *cp = (char *) (wp - 1);
+ while (*cp++ == 0)
+ continue;
+
+ return cp > buf + bufsize;
+}
+
 /* Write to FD the buffer BUF of size SIZE, processing any signals
    that arrive.  Return the number of bytes written, setting errno if
    this is less than SIZE.  Keep trying if there are partial
@@ -877,9 +905,28 @@ iwrite (int fd, char const *buf, size_t 
 
   while (total_written < size)
     {
-      ssize_t nwritten;
+      ssize_t nwritten = 0;
       process_signals ();
-      nwritten = write (fd, buf + total_written, size - total_written);
+
+      /* Perform a seek for a NUL block if sparse output is enabled. */
+      final_op_was_seek = false;
+      if ((conversions_mask & C_SPARSE) && is_nul (buf, size))
+        {
+          if (lseek (fd, size, SEEK_CUR) < 0)
+            {
+              conversions_mask &= ~C_SPARSE;
+              /* Don't warn about the advisory sparse request. */
+            }
+          else
+            {
+              final_op_was_seek = true;
+              nwritten = size;
+            }
+        }
+
+      if (!nwritten)
+        nwritten = write (fd, buf + total_written, size - total_written);
+
       if (nwritten < 0)
         {
           if (errno != EINTR)
@@ -1625,6 +1672,11 @@ dd_copy (void)
       obuf = ibuf;
     }
 
+  /* Write a sentinel to the slop after the buffer,
+     to allow efficient checking for NUL blocks. */
+  assert (sizeof (uintptr_t) <= OUTPUT_BLOCK_SLOP);
+  memset (obuf + output_blocksize, 1, sizeof (uintptr_t));
+
   if (skip_records != 0)
     {
       uintmax_t us_bytes = input_offset + (skip_records * input_blocksize);
@@ -1813,6 +1865,33 @@ dd_copy (void)
         }
     }
 
+  /* If the last write was converted to a seek, then for a regular file,
+     ftruncate to extend the size.  */
+  if (final_op_was_seek)
+    {
+      struct stat stdout_stat;
+      if (fstat (STDOUT_FILENO, &stdout_stat) != 0)
+        {
+          error (0, errno, _("cannot fstat %s"), quote (output_file));
+          return EXIT_FAILURE;
+        }
+      if (S_ISREG (stdout_stat.st_mode))
+        {
+          off_t output_offset = lseek (STDOUT_FILENO, 0, SEEK_CUR);
+          if (output_offset > stdout_stat.st_size)
+            {
+              if (ftruncate (STDOUT_FILENO, output_offset) != 0)
+                {
+                  error (0, errno,
+                         _("failed to truncate to %"PRIuMAX" bytes"
+                           " in output file %s"),
+                         output_offset, quote (output_file));
+                  return EXIT_FAILURE;
+                }
+            }
+        }
+    }
+
   if ((conversions_mask & C_FDATASYNC) && fdatasync (STDOUT_FILENO) != 0)
     {
       if (errno != ENOSYS && errno != EINVAL)
diff -urNp coreutils-8.4-orig/tests/dd/sparse coreutils-8.4/tests/dd/sparse
--- coreutils-8.4-orig/tests/dd/sparse	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-8.4/tests/dd/sparse	2013-07-24 18:01:34.183508831 +0200
@@ -0,0 +1,64 @@
+#!/bin/sh
+
+# Copyright (C) 2012 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+if test "$VERBOSE" = yes; then
+  set -x
+  dd --version
+fi
+
+. $srcdir/test-lib.sh
+require_sparse_support_
+
+# Ensure basic sparse generation works
+truncate -s1M sparse
+dd bs=32K if=sparse of=sparse.dd conv=sparse
+test $(stat -c %s sparse) = $(stat -c %s sparse.dd) || fail=1
+
+# Demonstrate that conv=sparse with oflag=append,
+# will do ineffective seeks in the output
+printf 'a\000\000b' > file.in
+printf 'ab' > exp
+dd if=file.in bs=1 conv=sparse oflag=append > out
+compare exp out || fail=1
+
+# Demonstrate conv=sparse with conv=notrunc,
+# where data in file.out is not overwritten with NULs
+printf '____' > out
+printf 'a__b' > exp
+dd if=file.in bs=1 conv=sparse,notrunc of=out
+compare exp out || fail=1
+
+# Ensure we fall back to write if seek fails
+dd if=file.in bs=1 conv=sparse | cat > file.out
+cmp file.in file.out || fail=1
+
+# Setup for block size tests
+dd if=/dev/urandom of=file.in bs=1M count=1
+truncate -s+1M file.in
+dd if=/dev/urandom of=file.in bs=1M count=1 conv=notrunc oflag=append
+
+# Ensure NUL blocks smaller than the block size are not made sparse
+dd if=file.in of=file.out bs=2M conv=sparse
+test $(stat -c %s file.in) = $(stat -c %s file.out) || fail=1
+test $(stat -c %b file.in) = $(stat -c %b file.out) && fail=1
+
+# Ensure NUL blocks >= block size are made sparse
+dd if=file.in of=file.out bs=1M conv=sparse
+test $(stat -c %s file.in) = $(stat -c %s file.out) || fail=1
+test $(stat -c %b file.in) = $(stat -c %b file.out) || fail=1
+
+Exit $fail
diff -urNp coreutils-8.4-orig/tests/Makefile.am coreutils-8.4/tests/Makefile.am
--- coreutils-8.4-orig/tests/Makefile.am	2013-07-24 17:50:50.128870996 +0200
+++ coreutils-8.4/tests/Makefile.am	2013-07-24 18:00:45.109422394 +0200
@@ -326,6 +326,7 @@ TESTS =						\
   dd/skip-seek					\
   dd/skip-seek2					\
   dd/skip-seek-past-file			\
+  dd/sparse					\
   dd/stderr					\
   dd/unblock					\
   dd/unblock-sync				\
